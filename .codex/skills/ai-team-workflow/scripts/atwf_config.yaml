# ai-team-workflow config (unified)
#
# This file is YAML (or JSON) and is parsed via `yaml.safe_load` when available.
#
# In this repo, `ai-team-workflow` is self-contained:
# - it bundles `tmux-workflow` (twf) and `codex-account-pool` (cap) under `deps/`
# - this single file configures atwf + twf + cap (so you don't edit multiple config files)
#
# Notes:
# - atwf reads: `share.*`, `team.*`
# - tmux-workflow (twf) reads: `codex.*`, `twf.*` (via `TWF_CODEX_CMD_CONFIG`)
# - codex-account-pool (cap) reads: `cap.*` (via env defaults injected by atwf)
#
# tmux-workflow (twf): Codex model defaults
codex:
  model: gpt-5.2
  model_reasoning_effort: high

  # Optional profile (equivalent to `codex -p <profile>`).
  # Leave empty for portability; prefer auth files over profiles when using account_pool.
  profile: ""

  # Optional Python virtualenv for Codex workers.
  #
  # When set (non-empty), tmux-workflow will export:
  # - VIRTUAL_ENV=<python_venv>
  # - PATH=<python_venv>/bin:<original PATH>
  #
  # so `python/pip` executed by Codex uses this venv.
  #
  # Recommended: absolute path. Example: "/root/.virtualenvs/uxbot"
  python_venv: ""

# Claude Code CLI defaults (optional)
claude:
  # Base Claude command (without --session-id / --resume; twf manages session selection).
  cmd: "claude"

  # Extra args for Claude (optional). Example: "--model sonnet".
  args: ""

# tmux-workflow (twf): worker lifecycle + auth/account-pool integration
twf:
  # Worker state directory (where twf writes its worker state JSON files)
  state_dir:
    mode: auto
    dir: ""

  # If false, twf will ignore TWF_AUTH_SRC/TWF_CODEX_HOME_SRC/TWF_CODEX_PROFILE
  # so tmux server/global env can't silently override project config.
  env:
    allow_overrides: false

  # Optional dependency: multi-account account pool
  account_pool:
    enabled: false
    cmd: ""  # optional override path to `cap`

    auth_team:
      # Directory containing multiple auth files (contents are Codex auth JSON).
      # Required when `account_pool.enabled=true`.
      dir: ""
      glob: "auth.json*"

      # - balanced: least-used (per-worker pick)
      # - team_cycle: one auth for the whole team; rotate only when advanced
      strategy: team_cycle

    # Team-wide auto-rotation (only meaningful when auth_team.strategy=team_cycle).
    # Consumed by ai-team-workflow (starts a background `cap watch-team` tmux session).
    watch_team:
      enabled: false
      interval: 180
      grace: 300
      max_retries: 10
      needle: "You've hit your usage limit."
      message: "Task continues. If you are waiting for a reply, please ignore this message."

  # Default auth when account pool is disabled.
  # When set (non-empty), twf copies this file into each worker as `auth.json`.
  auth:
    src: ""

# codex-account-pool (cap): shared CODEX_HOME source selection + auth pick state
cap:
  # Comma-separated list of CODEX_HOME template directories (optional; default fallback is `~/.codex`)
  sources: ""

  # - round_robin (default): picks sources sequentially (persists counter in state_file)
  # - hash: stable selection based on worker name (no state)
  strategy: round_robin

  # Where to persist cap's counters/pointers (relative to ai-team-workflow root unless absolute).
  state_file: "share/state/cap_state.json"

# Share dir (where registry/task/design/ops live):
# - If set (non-empty), it overrides the default shared state directory.
# - Recommended: absolute path
# - Relative paths are resolved from the skill root (`.codex/skills/ai-team-workflow/`)
#
# Default when unset/empty: <skill_root>/share
share:
  dir: ""

# Backward-compatible (older scripts):
# share_dir: ""

# Team policy (hard constraints)
#
# Notes:
# - 权限/可雇佣关系写在 policy（硬约束）里，不写在角色模板里。
# - 组织树（谁雇佣谁、开几个 dev/test）由父角色在运行时决定，但必须满足下面的规则。
team:
  policy:
    # Root role (single root). Non-root roles must be created via spawn (must have a parent).
    root_role: "coord"

    # Project-enabled roles (must have a matching templates/<role>.md).
    enabled_roles:
      - coord
      - admin
      - dev
      - reviewer
      - test

    # Hiring policy (who can spawn which roles). The parent decides the actual org by spawning,
    # but the role types must be allowed here.
    can_hire:
      coord: [admin]
      admin: [dev, reviewer, test]
      # Optional self-scaling (interns/assistants) by role label (e.g. dev-intern):
      dev: [dev]

    # Broadcast governance
    broadcast:
      allowed_roles: [coord]
      exclude_roles: []

    # Direct communication governance (who can DM/ask whom without handoff)
    comm:
      # Allow parent<->child communications regardless of role.
      allow_parent_child: true

      # Role-to-role direct communication matrix (bidirectional).
      # Example: dev (including dev interns) can talk to test/reviewer directly.
      direct_allow:
        # Anyone can ask coord for routing/authorization.
        coord: [admin, dev, reviewer, test]
        admin: [dev, reviewer, test]
        dev: [reviewer, test]
        reviewer: [test]

      # Otherwise, cross-branch conversations require a handoff/permit (to avoid relaying).
      require_handoff: true

      # Who can create handoffs/permits.
      handoff_creators: [coord, admin]

  # Init behavior (`atwf init`)
  #
  # - Starts the single root (team.policy.root_role) with base `<root_role>-<root_label>`.
  # - Optionally spawns configured children under the root (team.init.children).
  #
  # Back-compat default when `team.init.children` is unset:
  # - spawn pm-main + liaison-main (only if those roles are enabled/hireable)
  #
  # To remove pm/liaison completely:
  # - remove them from team.policy.enabled_roles (and update can_hire/direct_allow/handoff_creators accordingly)
  # - set:
  #     team.init.children: []
  #     team.init.task_to_role: ""
  init:
    root_label: "main"

    # Children to spawn under root during `atwf init`.
    # Each item can be:
    # - a role string: "pm"
    # - a dict: {role, label, scope} (or `base` to override the computed base name)
    children: []

    # Who receives the initial [TASK] inbox notice after init.
    # - default: "pm"
    # - set "" to disable auto-notify
    task_to_role: coord

  # Drive loop (anti-stall)
  #
  # When `mode=running`, the watcher will treat "a drive unit is idle + inbox-empty"
  # as an abnormal stall and will wake a single driver to re-kickoff work.
  #
  # Drive units:
  # - If `unit_role` is set and enabled (default: admin), each subtree rooted at that role
  #   is monitored independently.
  # - If `unit_role` is empty (or not enabled), the whole team is monitored as one unit (legacy).
  drive:
    mode: running # running | standby
    unit_role: admin      # role name for subtree drive; set "" to use whole-team drive
    driver_role: coord     # who is woken to drive the team
    backup_role: coord     # escalation target if driver is missing
    cooldown: 600          # seconds between repeated drive nudges
    message:
      # Summary is what gets injected into the driver’s Codex prompt (short).
      # Body is stored in inbox-open <msg_id> (full details).
      #
      # Placeholders:
      # - {{iso_ts}}   detection timestamp (ISO8601)
      # - {{msg_id}}   inbox message id
      # - {{open_cmd}} open command for the inbox body
      # - {{count}}    number of stalled units in this drive tick
      # - {{unit_role}} drive unit root role (e.g. admin)
      # - {{subtree_bases}} short list of stalled unit bases (for summary)
      # - {{subtree_lines}} multi-line detail list of stalled units (for body)
      summary: |
        [DRIVE] stalled {{unit_role}} subtrees: {{count}} ({{subtree_bases}})
        inbox id={{msg_id}} (open: {{open_cmd}})
        Rule: DO NOT change team.drive.mode or edit atwf_config.yaml (operator-only).
        Action: inspect each subtree, then re-drive (resume/assign) or stop it to exclude from drive scanning.
      body: |
        [DRIVE] stalled {{unit_role}} subtrees: {{count}}
        - detected_at: {{iso_ts}}

        Subtrees:
        {{subtree_lines}}

        Hard rule (operator-only):
        - DO NOT change team.drive.mode.
        - DO NOT edit {{ATWF_CONFIG}}.

        Coordinator actions:
        1) Inspect a subtree:
        - {{ATWF_CMD}} tree <subtree_base>
        - {{ATWF_CMD}} state <subtree_base>
        - {{ATWF_CMD}} inbox --target <subtree_base>

        2) Re-drive/restart a subtree:
        - {{ATWF_CMD}} resume --subtree <subtree_base>

        3) If DONE/BLOCKED and awaiting acceptance, freeze + stop scanning:
        - {{ATWF_CMD}} stop --subtree <subtree_base>
          (resume re-enables scanning)

  # Reply-needed requests (fan-in replies without CLI injection)
  #
  # - Initiator uses: `{{ATWF_CMD}} gather ...`
  # - Targets reply via: `{{ATWF_CMD}} respond ...` (or `--blocked` to snooze reminders)
  # - Watcher will reply-drive (wake debtors) when team is stalled but replies are pending.
  reply:
    deadline: 3600        # seconds until auto-timeout / consolidation
    blocked_snooze: 900   # default snooze for `atwf respond --blocked` (seconds)

  # Message delivery (hard default behavior)
  # - Full message bodies are stored in {{TEAM_DIR}}/inbox/...
  # - Chat prompts contain only short [INBOX] id=... notifications
  messaging:
    inbox:
      # Max active unread items per sender->recipient thread; older unread are moved to inbox/overflow.
      max_unread_per_thread: 15

  # Agent standby + inbox polling
  #
  # Notes:
  # - "working" agents should proactively check inbox periodically to avoid queue buildup.
  # - "idle" agents do NOT proactively poll inbox; they are woken by `atwf watch-idle` (operator sidecar).
  state:
    # While working, check inbox at least every N seconds.
    inbox_check_interval: 60

    # If a member is idle and new inbox messages arrive, schedule a wakeup after N seconds.
    idle_wake_delay: 60

    # Poll interval for `atwf watch-idle` (seconds).
    watch_interval: 60

    # Activity-derived state (watcher-managed).
    #
    # The watcher infers `working` vs `idle` by sampling the worker's tmux pane output:
    # - if the output hash changed within `activity_window`, consider it active (`working`)
    # - after a wake injection, keep it active for `active_grace_period` to avoid flapping
    activity_window: 120
    active_grace_period: 180
    activity_capture_lines: 200

    # Auto-unblock: if Codex is showing an approval menu inside the worker TUI,
    # send an Enter keystroke to accept the default choice and continue.
    auto_enter:
      enabled: true
      cooldown: 30
      tail_window_lines: 80
      patterns:
        - "3. No, and tell Codex what to do differently (esc)"

    # Minimal wake message injected into Codex TUI (no full body here).
    wake_message: "INBOX wake: you have unread messages. Run: {{ATWF_CMD}} inbox"
    reply_wake_message: "REPLY wake: you have pending reply-needed. Run: {{ATWF_CMD}} reply-needed"

    # Governance: if a worker is `working` but has pending inbox items older than N seconds,
    # the watcher writes an inbox-only alert to coord (no CLI injection).
    working_stale_threshold: 180
    working_alert_cooldown: 600
