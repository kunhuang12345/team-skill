<!--
本文件用于：在 `tmux-workflow` 的“阶段 1（Claude → Codex）”已实现的基础上，
把方案升级为“支持多个 Codex worker 并发、互不串台”的改造设计。

你当前的阶段 1 实现主要通过：
- tmux 注入输入（send-keys / paste-buffer）
- 轮询读取 `~/.codex/sessions/**/*.jsonl`（按 cwd 匹配 + 最新 mtime + 可能切换文件）

问题：如果同一时间启动多个 Codex（尤其是同 cwd），仅凭 cwd/mtime 很容易选错 jsonl，从而串台。

落地状态（当前仓库实现）：
- ✅ `scripts/codex_up_tmux.sh`：为每个 tmux worker 分配独立 `CODEX_HOME`（默认 `~/.codex-workers/<worker_id>`），并按你的要求同步 `~/.codex`（排除 `sessions/`、`log/`、`history.jsonl`）。
- ✅ session 文件：写入 `codex_home` / `codex_session_root` / `worker_id`。
- ✅ `scripts/codex_ask.py` / `scripts/codex_pend.py` / `scripts/codex_ping.py`：优先使用 session 文件里的 `codex_session_root` 来定位日志，避免跨 worker 扫描导致串台。
-->

# tmux-workflow 阶段 1 改造设计（支持多 Codex 并发，不串台）

## 0. 命名与状态（当前实现补充）

- 推荐入口脚本：`scripts/twf`（`twf` = `tmux-workflow`）。
- `twf <base>` 启动时会自动生成 worker 全名：`<base>-YYYYmmdd-HHMMSS-<pid>`（避免同名冲突）；该全名同时作为 tmux session 名与 `worker_id`。
- `twf` 的 session/state 文件默认在 `./.twf/`：`./.twf/<full-name>.json`（可用 `TWF_STATE_DIR` 覆盖）。
- 每个 worker 的隔离 `CODEX_HOME` 默认在 `~/.codex-workers/<worker_id>`（可用 `TWF_WORKERS_DIR` 覆盖）。
- 生命周期：
  - `twf stop <name|full-name>`：只停止 tmux session（保留 state 与 `CODEX_HOME`），后续可 `resume`。
  - `twf resume <name|full-name>`：恢复 worker（默认递归恢复子树，可用 `--no-tree` 只恢复自己）。
- 清理：`twf remove <full-name>`（必须用全名）默认递归删除子树（可用 `--no-recursive` 只删单点），会停止 tmux session，并删除该 worker 的 `CODEX_HOME` 与对应 state json。
- 父子关系：`twf spawn <parent-full> <child-base>` + `twf tree` / `twf list`（详见 `twf-design/3.sub_codex.md`）。

## 1. 目标与结论

目标：允许你同时启动多个 Codex worker（例如 2~N 个 tmux session/pane），并且：
- `codex_ask.py` 发送到哪个 tmux target，就只等待并读取该 worker 对应的日志与回复
- 不会因为另一个 Codex 会话产生了“更新的 jsonl 文件”而切到错误日志

结论：**最稳的办法是“每个 worker 独立 sessions 根目录”**，也就是：
- 每个 worker 使用独立的 `CODEX_HOME`（或 `CODEX_SESSION_ROOT`）
- 只复制 `~/.codex` 里“非会话数据”的文件到 worker home（不复制 `sessions/ log/ history.jsonl`）
- session 文件里记录该 worker 的 `codex_home` / `codex_session_root`，让 `codex_ask.py` 只在这个 root 下找 jsonl

这样即便你同一时间开 10 个 Codex 并发，也不会串台（物理隔离）。

---

## 2. 你确认的“需要复制”的内容

你明确要求：**除了 `history.jsonl`、`log/`、`sessions/` 这三个以外，其余 `~/.codex` 下的所有内容都必须复制**（包括 `.auth_trash/`、`skills/`、以及所有 `auth.json.*` 这类多账号/多 provider 的文件）。

按你当前 `~/.codex` 结构，意味着 worker home 至少应包含：
- `config.toml`
- `auth.json`、`.auth_current_name`
- `auth.json.*`（例如 `auth.json.1102` / `auth.json.outlook` / `auth.json.88code` 等）
- `.auth_trash/`（你当前有 `auth.json.bak.20251225-173417`）
- `rules/`
- `skills/`（包含 `skills/.system`）
- `version.json`

必须不复制（仅这三项）
- `sessions/`
- `log/`
- `history.jsonl`

---

## 3. 改造点总览（改哪些脚本/数据结构）

你已经有：
- `scripts/codex_up_tmux.sh`：启动 tmux 里 `codex ...`，并写 `./.codex-tmux-session.json`
- `scripts/codex_ask.py`：tmux 注入 + 轮询 jsonl

为了支持多 worker，不串台，需要做 3 类修改：

1) `codex_up_tmux.sh`：为每个 tmux worker 创建/分配独立 `CODEX_HOME`，并把主 `~/.codex` 的“非会话数据”同步进去  
2) session 文件结构：记录 `codex_home`（或 `codex_session_root`）以及 worker 标识（tmux session 名/target）  
3) `codex_ask.py`：从 session 文件读取 `codex_home`/`codex_session_root`，只在该 root 下找 jsonl；并移除“全局最新文件切换”导致串台的路径  

---

## 4. 方案 A（推荐）：worker 池 + 独立 CODEX_HOME（配置复制，无软链）

### 4.1 worker 池目录约定

建议在用户目录下创建一个固定位置：

- `~/.codex-workers/<worker_id>/` 作为该 worker 的 `CODEX_HOME`
- `<worker_id>` 建议直接用 tmux session 名（例如 `codex-<hash>`），保证每个项目/worker 稳定

这样目录数量 = 并发 worker 数（常数级），不会随着“分发次数”增长。

### 4.2 在 codex_up_tmux.sh 的改法

新增逻辑：

1. 计算 `worker_id`（可等于 `tmux_session`）
2. 设定 `worker_home="$HOME/.codex-workers/$worker_id"`
3. 同步主配置到 worker home（不复制 sessions/log/history）
4. 启动 tmux session 时，让 `codex` 在该 worker home 下运行：
   - 方式 1：`tmux new-session ... "env CODEX_HOME='$worker_home' codex ..."`
   - 方式 2：`tmux set-environment -t "$tmux_session" CODEX_HOME "$worker_home"` 后再启动 codex

同步函数（伪代码，按你口径“除了三项都复制”）：

```bash
sync_codex_home() {
  local src="$HOME/.codex"
  local dst="$1"
  mkdir -p "$dst"
  # 只排除 3 项：sessions/log/history（其余全部复制）
  rsync -a --delete \
    --exclude 'sessions/' \
    --exclude 'log/' \
    --exclude 'history.jsonl' \
    "$src/" "$dst/"
  # 确保每个 worker 都有独立 sessions 目录
  mkdir -p "$dst/sessions"
}
```

注意：这能保证你改了 `~/.codex/config.toml` 后，只要你重启 worker 或再次执行 `codex_up_tmux.sh`，新 worker 会继承最新配置。  
（已在运行中的 Codex 是否热加载配置，通常不保证；要生效一般还是重启。）

### 4.3 session 文件（`.codex-tmux-session.json`）新增字段

在你现有字段基础上增加：

- `codex_home`: `~/.codex-workers/<worker_id>`
- `codex_session_root`: `<codex_home>/sessions`（可选，冗余但方便）
- `worker_id`: `<worker_id>`（可选）

这样 `codex_ask.py` 不再依赖全局 `~/.codex/sessions`。

---

## 5. codex_ask.py 的改法（避免串台的关键）

你现有逻辑是：
- `_sessions_root()` 可能回退到 `~/.codex/sessions`
- `_find_log_for_cwd()` 用 `session_meta.cwd` 匹配当前 cwd 找文件
- `_poll_for_reply()` 允许 rescan，并可能切换到新的 log 文件（`current_path = candidate; current_offset = 0`）

在“多 worker 独立 CODEX_HOME”的新方案下，修改为：

### 5.1 sessions_root 只从 session 文件来

优先级建议：
1. `session["codex_session_root"]`
2. `session["codex_home"] + "/sessions"`
3. 环境变量 `CODEX_SESSION_ROOT`
4. 环境变量 `CODEX_HOME + "/sessions"`
5. 最后才是 `~/.codex/sessions`（但多 worker 模式下不建议走到这里）

### 5.2 log 文件选择策略简化（每个 root 下只有该 worker 的会话）

在 worker 独立 root 下，你不必用 cwd 去匹配了：
- 优先用 `session["codex_session_path"]`（存在则用）
- 否则用 “该 root 下 mtime 最新的 `*.jsonl`”（通常就是该 worker 当前 session）
- 必要时再读第一行 `session_meta.payload.id`，把 `codex_session_id` 写回 session 文件

### 5.3 禁止“跨 root 的 latest 切换”

`allow_rescan` 可以保留，但 rescan 只能在 **该 worker 的 sessions_root 内**进行。  
只要你不再扫描全局 `~/.codex/sessions`，就不会被别的 worker 的日志影响。

---

## 6. 多会话同时启动时，如何区分 session_id？

在“独立 CODEX_HOME”方案里，这个问题基本被消灭：
- 因为每个 worker 的 `sessions_root` 只会出现它自己的 jsonl
- `codex_up_tmux.sh` 或 `codex_ask.py` 第一次绑定时，读该 root 下最新 jsonl 的 `session_meta.payload.id` 即可

如果你坚持“所有 worker 共用 `~/.codex`”，那就必须做“握手标记”去反查哪个 jsonl 属于哪个 pane；  
但这会让实现更复杂且更脆弱，本文件不推荐在阶段 1 走这条路。

---

## 7. 改造后的验收点（你怎么确认没串台）

1. 在同一个项目 cwd 下，执行两次 `codex_up_tmux.sh`，用不同 `--session` 启动两个 worker
2. 分别对两个 worker 执行 `codex_ask.py`（可以通过不同 `--session-file` 或不同 cwd 的 session 文件）
3. 观察：
   - 两个 worker 的 `codex_home` 不同
   - 两个 worker 的 `codex_session_root` 不同
   - A 的提问只在 A 的 jsonl 增长，B 同理
   - `codex_ask.py` 不会因为另一个 worker 的 jsonl 更新而切换/读到对方回复

---

## 8. 你要我怎么帮你落地（选项）

你确认要改的话，我可以按这个改造设计直接提交补丁（改 `scripts/codex_up_tmux.sh` + `scripts/codex_ask.py` + session JSON 字段），并给出一个最小的并发演示命令集。
