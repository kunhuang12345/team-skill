# 3. sub-codex：父子 Codex（递归 resume / remove / tree）

本设计文档基于当前已实现的阶段 1 与多 worker 方案（见 `twf-design/2.muti_codex.md`），补充：

- `twf resume`：恢复一个 worker（以及它的子树）
- `twf stop`：只关闭 tmux / Codex 进程但保留状态，后续可 resume
- `twf remove --recursive`：递归删除子树，避免游荡 tmux pane
- `twf tree` / `twf list`：展示父子结构与运行态

落地状态（当前仓库实现，`scripts/twf`）：

- ✅ `twf stop/resume/spawn/tree/list/remove`（`remove` 默认递归；`--no-recursive` 只删单点）
- ✅ state 锁：`~/.twf/.lock`（`flock`）
- ✅ state 字段：`parent/children/codex_current_id/codex_resume_from_id`

## 3.1 背景：为什么要“存 id”，以及 resume 为什么会“变 id”

Codex 的落盘日志 `sessions/**/*.jsonl` 里会有 `session_meta.payload.id`（UUID）。你观察到的现象是：

- `codex resume <old_id>` 继续对话后，日志里出现新的 `session_meta.payload.id`（新的 UUID）
- 也就是：**resume 更像“以上一次会话为基底开启新的 session/rollout”，而不是持续复用同一个 session_id**

因此我们的状态里需要区分两类 id：

- `codex_resume_from_id`：下一次要传给 `codex resume <id>` 的 id（通常等于“上一次运行结束前观察到的 current id”）
- `codex_current_id`：当前运行过程中最新的 id（用于展示/诊断；下次 stop 时会变成新的 `resume_from_id`）

> 重要：resume 的“正确性”不依赖 jsonl 文件名；应以 `session_meta.payload.id` 为准。

---

## 3.2 术语与对象

### Node（一个 Codex worker）

一个 Node 对应一个 tmux session（本项目当前默认 “worker 全名 = tmux session 名”）以及一个独立的 `CODEX_HOME`：

- tmux：`<worker_full_name>`
- CODEX_HOME：`~/.codex-workers/<worker_id>`（默认 `<worker_id> == <worker_full_name>`）
- state file：`~/.twf/<worker_full_name>.json`（默认）

### Tree（父子关系）

父子关系是 **“编排关系”**，不是 Codex 自带能力。它由 `twf` 写入 state 来维护：

- parent 节点记录 `children[]`
- child 节点记录 `parent`

子节点也可以有子节点，形成递归树。

---

## 3.3 State 文件 schema（建议）

当前 `twf` 已写入的基础字段（tmux / codex_home / session_root / start_cmd 等）保持不变，新增以下字段：

```jsonc
{
  "worker_id": "codex-a-20251228-203040-12345",
  "tmux_session": "codex-a-20251228-203040-12345",
  "tmux_target": "codex-a-20251228-203040-12345:0.0",

  "codex_home": "/root/.codex-workers/codex-a-20251228-203040-12345",
  "codex_session_root": "/root/.codex-workers/codex-a-20251228-203040-12345/sessions",

  // resume 相关
  "codex_resume_from_id": "019b....",   // 下次用于 `codex resume <id>`
  "codex_current_id": "019b....",       // 本次运行后最新 id（通常会变化）
  "codex_session_path": "/.../sessions/2025/.../rollout-...jsonl",
  "codex_start_cmd": "codex -c disable_paste_burst=true",
  "codex_resume_cmd": "codex -c disable_paste_burst=true resume 019b....", // 可选：缓存

  // 树结构
  "parent": "codex-main-20251228-200000-9999",   // 可选
  "children": [
    "codex-sub1-20251228-201000-1111",
    "codex-sub2-20251228-202000-2222"
  ],

  // 生命周期（可选，便于 list/tree 展示）
  "active": true,
  "created_at": "2025-12-28 20:30:40",
  "stopped_at": "2025-12-28 21:10:00",
  "resumed_at": "2025-12-28 22:05:00"
}
```

关键约束：

1. **`remove` 与 `resume` 的主键永远用 `worker_full_name`（也就是 state 文件名）**，避免“base 名”指向变化导致误操作。
2. `children` 必须存 `worker_full_name`，而不是短名（base），否则无法稳定定位到唯一节点。

---

## 3.4 新命令设计（twf）

### 3.4.1 `twf stop <name|full-name>`

目的：停止运行但保留恢复所需的全部信息（state + codex_home + sessions）。

行为：
- kill tmux session（等价于停止该 worker）
- **不删除** `codex_home`
- **不删除** state json
- 更新 state：
  - `active=false`
  - 从该 worker 的 `codex_session_root` 中解析“最新 `session_meta.payload.id`”写入 `codex_resume_from_id`
    - 如果此时有 `codex_current_id`，也同步更新

为什么需要 stop：
- 你希望“关闭后还能 resume”；而当前的 `twf remove` 是破坏性删除（删 state + 删 codex_home），无法恢复。

### 3.4.2 `twf resume <name|full-name> [--tree|--no-tree]`

目的：恢复一个 worker。如果它有子树，默认递归恢复（可用 `--no-tree` 仅恢复自己）。

恢复步骤（单节点）：
1. 读取 state file
2. 如果 tmux session 已存在且存活：认为已运行，直接返回（可选输出 “already running”）
3. 否则启动 tmux session：
   - `CODEX_HOME=<codex_home>`（必须）
   - 启动命令：
     - 若存在 `codex_resume_from_id`：运行 `codex ... resume <codex_resume_from_id>`
     - 否则：运行 `codex ...`（相当于新会话）
4. 启动成功后：
   - 重新扫描该 worker 的 `codex_session_root`，找到最新 jsonl 的 `session_meta.payload.id` 写入 `codex_current_id`
   - `active=true`、`resumed_at=...`

递归恢复（树）：
- 在恢复父节点后，按 `children[]` 顺序对每个 child 执行相同恢复
- 要求：所有 child 的 state file 都能被找到；找不到的 child 记录为 warning，并从 parent 的 `children[]` 中清理（可选：提供 `--no-prune` 保留）

### 3.4.3 `twf spawn <parent_full_name> <child_base> [up-args...]`

目的：由父节点创建子节点并绑定关系（“由主 Codex 开启子 Codex”）。

行为：
1. 启动 child worker（复用现有 `twf up <child_base>` 的逻辑，生成新的 `<child_full_name>`）
2. 写 child state：`parent=<parent_full_name>`
3. 更新 parent state：将 `<child_full_name>` 追加到 `children[]`（去重）

> 谁发起 spawn 并不重要：可以是你手动执行、Claude 执行、或 Codex 执行；核心是 `twf` 负责落盘维护关系。

### 3.4.4 `twf remove <full-name> [--recursive|--no-recursive]`

目标：解决“递归链被 remove 后产生游荡 pane”。

建议默认：`--recursive`（递归删除子树）。

递归删除策略（单节点 N）：
1. 先确定子节点集合（两条路合并去重）：
   - `children[]` 里显式列出的
   - state_dir 全扫描，找 `parent == N`
2. 对子节点先递归 remove（后序遍历：先删子、再删父）
3. kill N 的 tmux session
4. 删除 N 的 `codex_home`（仍需安全检查：必须在 `TWF_WORKERS_DIR` 下）
5. 删除 N 的 state json
6. 若 N 有 parent：从 parent 的 `children[]` 移除 N（best-effort）

### 3.4.5 `twf tree [root]` / `twf list`

`twf tree`：
- 展示父子结构（root 缺省时：自动找 “没有 parent 的节点” 作为 roots，或按时间排序展示）
- 每个节点显示：
  - `worker_full_name`
  - `active/running`（以 `tmux has-session` 判定为准）
  - `codex_resume_from_id`（短 8 位）与 `codex_current_id`（短 8 位）

`twf list`：
- 平铺显示所有节点，支持过滤：
  - `--running` / `--stopped`
  - `--orphans`（parent 不存在或 children 引用不存在）

---

## 3.5 关键实现细节（保证一致性）

### 3.5.1 并发一致性：写 state 要加锁

当父节点同时 spawn 多个子节点，或并发 resume/remove 时，很容易产生竞态。

建议：`state_dir/.lock` 用 `flock` 串行化所有 state 读写，保证：
- parent.children[] 不会丢写
- remove 递归时不被另一个进程同时 resume 破坏

### 3.5.2 解析“最新可 resume 的 id”

在 “每 worker 独立 `codex_session_root`” 前提下：

1. 找最新修改的 `*.jsonl`（mtime 最大）
2. 从文件头部读取第一条 `type=session_meta` 的 `payload.id`
3. 作为：
   - `codex_current_id`（运行中更新）
   - stop 时写入 `codex_resume_from_id`

> 你的日志里可能出现多个 `session_meta`，通常“最新的一条”会出现在文件头部更靠前的位置；以“最新 jsonl + 头部第一条 session_meta”最稳定。

### 3.5.3 resume 的前置条件

必须满足之一：
- state file 存在，且 `codex_home` 仍存在（包含之前 sessions）
- 或者允许“无历史 resume”：没有 `codex_resume_from_id` 时，resume 退化成新建会话

如果用户执行了 `remove`，则 state 与 codex_home 都删除，无法 resume，这是预期行为。

---

## 3.6 你提到的两个“坑”如何对应解决

### 坑 A：递归链被 remove → 游荡 pane

原因：
- 当前 `remove` 只删单点，不处理 children，导致子 tmux session 继续存活。

解决：
- `remove` 默认递归；并且用 “children[] + 反向扫描 parent 字段” 双重确认子集合，尽量覆盖不一致状态。

### 坑 B：resume 时只恢复主 codex，子 codex 没恢复

解决：
- 父节点 state 持久化 children[]
- `twf resume` 默认递归 `--tree`，逐个恢复子节点（存在就跳过，不存在就告警/清理引用）
