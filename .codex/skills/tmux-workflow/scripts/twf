#!/usr/bin/env bash
set -euo pipefail

script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

usage() {
  cat <<'USAGE' >&2
tmux-workflow helper: manage multiple Codex tmux workers with short names.

Usage:
  twf <name>                       # start a new worker: <name>-<timestamp>
  twf <name> "<message>"           # ask the latest worker for <name> (auto-up if missing)
  twf up <name> [up-args...]        # explicit start (forwards args to codex_up_tmux.sh)
  twf ask <name> [message]          # explicit ask (reads stdin if message omitted)
  twf pend <name> [N]               # show latest reply / last N Q&A
  twf ping <name>                   # health check
  twf self                          # print current worker full name (tmux session name)
  twf spawn-self <child> [up-args...]# spawn a child worker from the current worker (inside tmux)
  twf stop <name|full-name>          # stop tmux session but keep worker home + state (resume-able)
  twf resume <name|full-name>        # resume worker (default: resume subtree; pass --no-tree for single node)
  twf spawn <parent-full> <child>    # start child worker and link parent/child in state
  twf remove <full-name> [--no-recursive]  # delete worker (default: recursive subtree)
  twf tree [root-full]               # show parent/child tree (running status)
  twf list [--running|--stopped|--orphans] # list all workers (flat)

State:
  session files directory is configurable via `scripts/twf_config.yaml`:
    - auto:   <skill_root>/.twf/  (default)
    - global: ~/.twf/
    - manual: <twf_state_dir>  (must be set in config)
  override: `TWF_STATE_DIR=/some/path` (highest priority)
  file names:
    - timestamped: <name>-<YYYYmmdd-HHMMSS>-<pid>.json
    - exact:       <name>.json (used if no timestamped file exists)

Env:
  TWF_STATE_DIR       Override twf state dir (highest priority)
  TWF_WORKERS_DIR     Default: ~/.codex-workers     (forwarded to codex_up_tmux.sh)
  TWF_CODEX_HOME_SRC  Default: ~/.codex             (forwarded to codex_up_tmux.sh)
  TWF_AUTH_SRC        Optional: auth file to copy into worker as `auth.json` (overrides synced auth.json)
  TWF_CODEX_PROFILE   Optional: codex profile (equivalent to `codex -p <profile>`)
  TWF_LOAD_BALANCER_CMD  Optional: path to `codex-load-balancer/scripts/clb` (used when twf_use_load_balancer=true)
  TWF_CODEX_CMD_CONFIG  Default: scripts/twf_config.yaml (model + model_reasoning_effort + twf_state_dir_mode)
  TWF_CODEX_CMD       Override full codex command (forwarded to codex_up_tmux.sh)
USAGE
}

is_ts_name() {
  # <base>-YYYYmmdd-HHMMSS(-suffix)?
  [[ "$1" =~ -[0-9]{8}-[0-9]{6}(-[0-9]+)?$ ]]
}

base_from_full() {
  local full="${1:-}"
  if [[ "$full" =~ ^(.+)-[0-9]{8}-[0-9]{6}(-[0-9]+)?$ ]]; then
    echo "${BASH_REMATCH[1]}"
    return 0
  fi
  echo "$full"
  return 0
}

config_file="${TWF_CODEX_CMD_CONFIG:-$script_dir/twf_config.yaml}"
if [[ -z "${TWF_CODEX_CMD_CONFIG:-}" && ! -f "$config_file" && -f "$script_dir/twf_config.json" ]]; then
  config_file="$script_dir/twf_config.json"
fi
skill_dir="$(cd "$script_dir/.." && pwd)"

read_state_dir_config() {
  python3 - "$config_file" <<'PY'
import sys
from pathlib import Path
import json

cfg_path = Path(sys.argv[1]).expanduser()
raw = ""
try:
  if cfg_path.exists():
    raw = cfg_path.read_text(encoding="utf-8")
except Exception:
  pass

def parse_yaml(text: str) -> dict:
  out: dict[str, str] = {}
  for line in text.splitlines():
    stripped = line.strip()
    if not stripped or stripped.startswith("#"):
      continue
    if ":" not in stripped:
      continue
    key, value = stripped.split(":", 1)
    key = key.strip()
    if not key:
      continue
    value = value.strip()
    if not value:
      out[key] = ""
      continue
    if value[0] in {"'", '"'}:
      q = value[0]
      if value.endswith(q) and len(value) >= 2:
        out[key] = value[1:-1]
      else:
        out[key] = value[1:]
      continue
    if "#" in value:
      for i, ch in enumerate(value):
        if ch == "#" and (i == 0 or value[i - 1].isspace()):
          value = value[:i].strip()
          break
    out[key] = value.strip()
  return out

data = {}
try:
  if raw.lstrip().startswith("{"):
    data = json.loads(raw)
    if not isinstance(data, dict):
      data = {}
  else:
    data = parse_yaml(raw)
except Exception:
  data = parse_yaml(raw)

mode = data.get("twf_state_dir_mode", "auto")
if not isinstance(mode, str):
  mode = "auto"
mode = mode.strip().lower() or "auto"
manual_dir = data.get("twf_state_dir", "")
if not isinstance(manual_dir, str):
  manual_dir = ""
manual_dir = manual_dir.strip()

use_lb = data.get("twf_use_load_balancer", "false")
if isinstance(use_lb, bool):
  use_lb = "true" if use_lb else "false"
elif not isinstance(use_lb, str):
  use_lb = "false"
use_lb = use_lb.strip().lower() or "false"

lb_cmd = data.get("twf_load_balancer_cmd", "")
if not isinstance(lb_cmd, str):
  lb_cmd = ""
lb_cmd = lb_cmd.strip()

profile = data.get("twf_profile", "")
if not isinstance(profile, str):
  profile = ""
profile = profile.strip()

auth_src = data.get("twf_auth_src", "")
if not isinstance(auth_src, str):
  auth_src = ""
auth_src = auth_src.strip()

auth_team_dir = data.get("twf_auth_team_dir", "")
if not isinstance(auth_team_dir, str):
  auth_team_dir = ""
auth_team_dir = auth_team_dir.strip()

auth_team_glob = data.get("twf_auth_team_glob", "")
if not isinstance(auth_team_glob, str):
  auth_team_glob = ""
auth_team_glob = auth_team_glob.strip()

print(mode)
print(manual_dir)
print(use_lb)
print(lb_cmd)
print(profile)
print(auth_src)
print(auth_team_dir)
print(auth_team_glob)
PY
}

state_dir="${TWF_STATE_DIR:-}"
twf_use_lb="false"
twf_lb_cmd_cfg=""
twf_profile_cfg=""
twf_auth_src_cfg=""
twf_auth_team_dir_cfg=""
twf_auth_team_glob_cfg=""
if [[ -z "$state_dir" ]]; then
  readarray -t state_cfg < <(read_state_dir_config)
  mode="${state_cfg[0]:-auto}"
  manual_dir="${state_cfg[1]:-}"
  twf_use_lb="${state_cfg[2]:-false}"
  twf_lb_cmd_cfg="${state_cfg[3]:-}"
  twf_profile_cfg="${state_cfg[4]:-}"
  twf_auth_src_cfg="${state_cfg[5]:-}"
  twf_auth_team_dir_cfg="${state_cfg[6]:-}"
  twf_auth_team_glob_cfg="${state_cfg[7]:-}"
  case "$mode" in
    global)
      state_dir="$HOME/.twf"
      ;;
    manual)
      if [[ -z "$manual_dir" ]]; then
        echo "‚ùå twf_state_dir_mode=manual requires twf_state_dir to be set in $config_file (or set TWF_STATE_DIR)." >&2
        exit 1
      fi
      state_dir="$(python3 -c 'import os,sys; print(os.path.expanduser(sys.argv[1]))' "$manual_dir")"
      if [[ "$state_dir" != /* ]]; then
        state_dir="$PWD/$state_dir"
      fi
      ;;
    auto|*)
      state_dir="$skill_dir/.twf"
      ;;
  esac
fi
mkdir -p "$state_dir"
lock_file="$state_dir/.lock"

lower_bool() {
  local v="${1:-}"
  v="$(echo "$v" | tr '[:upper:]' '[:lower:]')"
  v="${v//[[:space:]]/}"
  [[ "$v" == "1" || "$v" == "true" || "$v" == "yes" || "$v" == "y" || "$v" == "on" ]]
}

resolve_lb_cmd() {
  local cmd="${TWF_LOAD_BALANCER_CMD:-}"
  if [[ -z "$cmd" ]]; then
    cmd="$twf_lb_cmd_cfg"
  fi

  if [[ -n "$cmd" ]]; then
    cmd="$(python3 - "$skill_dir" "$cmd" <<'PY'
import os
import sys
from pathlib import Path

base = Path(sys.argv[1]).resolve()
raw = sys.argv[2].strip()
p = Path(os.path.expanduser(raw))
if not p.is_absolute():
    p = (base / p).resolve()
print(str(p))
PY
)"
    echo "$cmd"
    return 0
  fi

  local sibling="$skill_dir/../codex-load-balancer/scripts/clb"
  if [[ -f "$sibling" ]]; then
    echo "$sibling"
    return 0
  fi

  local global="$HOME/.codex/skills/codex-load-balancer/scripts/clb"
  if [[ -f "$global" ]]; then
    echo "$global"
    return 0
  fi

  echo ""
  return 0
}

resolve_auth_src_cfg() {
  local raw="$1"
  [[ -n "$raw" ]] || return 0
  local resolved
  resolved="$(python3 - "$raw" <<'PY'
import os
import sys
from pathlib import Path

raw = sys.argv[1].strip()
p = Path(os.path.expanduser(raw))
if not p.is_absolute():
    p = (Path.cwd() / p).resolve()
print(str(p))
PY
)"
  echo "$resolved"
}

pick_codex_home_src() {
  local worker="$1"
  local base="$2"

  local cmd
  cmd="$(resolve_lb_cmd)"
  if [[ -z "$cmd" || ! -f "$cmd" ]]; then
    echo "‚ùå twf_use_load_balancer=true but codex-load-balancer not found." >&2
    echo "   Install sibling skill: ./.codex/skills/codex-load-balancer/, or set twf_load_balancer_cmd / TWF_LOAD_BALANCER_CMD." >&2
    exit 1
  fi

  local src
  src="$(bash "$cmd" pick --worker "$worker" --base "$base")"
  src="$(echo "$src" | tail -n 1 | xargs)"
  if [[ -z "$src" ]]; then
    echo "‚ùå load balancer returned empty CODEX_HOME source for worker=$worker" >&2
    exit 1
  fi
  if [[ ! -d "$src" ]]; then
    echo "‚ùå load balancer CODEX_HOME source does not exist: $src" >&2
    exit 1
  fi
  echo "$src"
}

pick_auth_src() {
  local worker="$1"
  local base="$2"

  local cmd
  cmd="$(resolve_lb_cmd)"
  if [[ -z "$cmd" || ! -f "$cmd" ]]; then
    echo "‚ùå twf_use_load_balancer=true but codex-load-balancer not found." >&2
    echo "   Install sibling skill: ./.codex/skills/codex-load-balancer/, or set twf_load_balancer_cmd / TWF_LOAD_BALANCER_CMD." >&2
    exit 1
  fi

  local src
  local env_args=()
  if [[ -n "$twf_auth_team_dir_cfg" ]]; then
    local auth_dir
    auth_dir="$(python3 - "$twf_auth_team_dir_cfg" <<'PY'
import os
import sys
from pathlib import Path

raw = sys.argv[1].strip()
p = Path(os.path.expanduser(raw))
if not p.is_absolute():
    p = (Path.cwd() / p).resolve()
print(str(p))
PY
)"
    env_args+=("CLB_AUTH_TEAM_DIR=$auth_dir")
  fi
  if [[ -n "$twf_auth_team_glob_cfg" ]]; then
    env_args+=("CLB_AUTH_TEAM_GLOB=$twf_auth_team_glob_cfg")
  fi
  if [[ ${#env_args[@]} -gt 0 ]]; then
    src="$(env "${env_args[@]}" bash "$cmd" pick-auth --worker "$worker" --base "$base")"
  else
    src="$(bash "$cmd" pick-auth --worker "$worker" --base "$base")"
  fi
  src="$(echo "$src" | tail -n 1 | xargs)"
  if [[ -z "$src" ]]; then
    echo "‚ùå load balancer returned empty auth source for worker=$worker" >&2
    exit 1
  fi
  if [[ ! -f "$src" ]]; then
    echo "‚ùå load balancer auth source does not exist: $src" >&2
    exit 1
  fi
  echo "$src"
}

lock_state() {
  exec 9>"$lock_file"
  flock -x 9
}

unlock_state() {
  exec 9>&- 2>/dev/null || true
}

now_human() {
  date +"%Y-%m-%d %H:%M:%S"
}

latest_session_file() {
  local name="$1"
  local candidates=()
  shopt -s nullglob
  candidates=("$state_dir/${name}-"*.json)
  shopt -u nullglob
  if [[ ${#candidates[@]} -gt 0 ]]; then
    ls -t "${candidates[@]}" 2>/dev/null | head -n 1
    return 0
  fi
  if [[ -f "$state_dir/$name.json" ]]; then
    echo "$state_dir/$name.json"
    return 0
  fi
  return 1
}

resolve_session_file_or_fail() {
  local name="$1"

  local session_file=""
  if is_ts_name "$name"; then
    session_file="$state_dir/$name.json"
  else
    session_file="$(latest_session_file "$name" 2>/dev/null || true)"
  fi

  if [[ -z "$session_file" || ! -f "$session_file" ]]; then
    echo "‚ùå no session for: $name" >&2
    exit 1
  fi
  echo "$session_file"
}

scan_latest_log_info() {
  local sessions_root="$1"
  python3 - "$sessions_root" <<'PY'
import json
import sys
from pathlib import Path

root = Path(sys.argv[1]).expanduser()
latest = None
latest_mtime = -1.0

for p in root.glob("**/*.jsonl"):
    if not p.is_file():
        continue
    try:
        mtime = p.stat().st_mtime
    except OSError:
        continue
    if mtime >= latest_mtime:
        latest = p
        latest_mtime = mtime

sid = None
if latest:
    try:
        with latest.open("r", encoding="utf-8", errors="ignore") as f:
            for _ in range(50):
                line = f.readline()
                if not line:
                    break
                line = line.strip()
                if not line:
                    continue
                try:
                    entry = json.loads(line)
                except Exception:
                    continue
                if not isinstance(entry, dict) or entry.get("type") != "session_meta":
                    continue
                payload = entry.get("payload") or {}
                if isinstance(payload, dict) and isinstance(payload.get("id"), str):
                    sid = payload["id"]
                    break
    except OSError:
        pass

print(str(latest) if latest else "")
print(sid or "")
PY
}

auth_src_default() {
  # Only used when load balancer is disabled AND no env override is provided.
  if lower_bool "$twf_use_lb"; then
    echo ""
    return 0
  fi
  if [[ -z "$twf_auth_src_cfg" ]]; then
    echo ""
    return 0
  fi

  local resolved
  resolved="$(resolve_auth_src_cfg "$twf_auth_src_cfg")"
  if [[ -z "$resolved" || ! -f "$resolved" ]]; then
    echo "‚ùå twf_auth_src is set but file does not exist: $twf_auth_src_cfg" >&2
    echo "   Resolved path: ${resolved:-<empty>}" >&2
    exit 1
  fi
  echo "$resolved"
}

start_worker() {
  local base="$1"
  shift || true

  local worker="$base"
  if ! is_ts_name "$base"; then
    local ts
    ts="$(date +%Y%m%d-%H%M%S)"
    worker="${base}-${ts}-$$"
  fi

  local session_file="$state_dir/$worker.json"
  local home_src="${TWF_CODEX_HOME_SRC:-}"
  if [[ -z "$home_src" ]] && lower_bool "$twf_use_lb"; then
    home_src="$(pick_codex_home_src "$worker" "$base")"
  fi

  local auth_src="${TWF_AUTH_SRC:-}"
  if [[ -z "$auth_src" ]] && lower_bool "$twf_use_lb"; then
    auth_src="$(pick_auth_src "$worker" "$base")"
  fi
  if [[ -z "$auth_src" ]] && ! lower_bool "$twf_use_lb"; then
    auth_src="$(auth_src_default)"
  fi

  if [[ -n "$home_src" || -n "$auth_src" ]]; then
    local env_args=()
    if [[ -n "$home_src" ]]; then
      env_args+=("TWF_CODEX_HOME_SRC=$home_src")
    fi
    if [[ -n "$auth_src" ]]; then
      env_args+=("TWF_AUTH_SRC=$auth_src")
    fi
    # Only apply profile when load balancer is disabled.
    if ! lower_bool "$twf_use_lb" && [[ -n "$twf_profile_cfg" ]]; then
      env_args+=("TWF_CODEX_PROFILE=$twf_profile_cfg")
    fi
    env "${env_args[@]}" bash "$script_dir/codex_up_tmux.sh" --session "$worker" --session-file "$session_file" "$@" 1>&2
  else
    bash "$script_dir/codex_up_tmux.sh" --session "$worker" --session-file "$session_file" "$@" 1>&2
  fi
  echo "$session_file"
}

self_worker() {
  if [[ -z "${TMUX:-}" ]]; then
    echo "‚ùå twf self must run inside tmux" >&2
    exit 1
  fi
  tmux display-message -p '#S'
}

spawn_self_worker() {
  local child_base="${1:-}"
  shift || true

  if [[ -z "$child_base" ]]; then
    echo "‚ùå usage: twf spawn-self <child-base> [up-args...]" >&2
    usage
    exit 1
  fi

  local parent
  parent="$(self_worker)"
  spawn_worker "$parent" "$child_base" "$@"
}

ask_worker() {
  local name="$1"
  shift || true

  local session_file=""
  if is_ts_name "$name"; then
    session_file="$state_dir/$name.json"
    if [[ ! -f "$session_file" ]]; then
      echo "‚ùå session not found: $session_file" >&2
      exit 1
    fi
  else
    session_file="$(latest_session_file "$name" 2>/dev/null || true)"
    if [[ -z "$session_file" ]]; then
      session_file="$(start_worker "$name")"
    fi
  fi

  if [[ $# -gt 0 ]]; then
    local msg
    msg="$*"
    python3 "$script_dir/codex_ask.py" --session-file "$session_file" "$msg"
  else
    python3 "$script_dir/codex_ask.py" --session-file "$session_file"
  fi
}

pend_worker() {
  local name="$1"
  shift || true

  local session_file=""
  if is_ts_name "$name"; then
    session_file="$state_dir/$name.json"
  else
    session_file="$(latest_session_file "$name" 2>/dev/null || true)"
  fi

  if [[ -z "$session_file" || ! -f "$session_file" ]]; then
    echo "‚ùå no session for: $name (run: twf $name)" >&2
    exit 1
  fi

  python3 "$script_dir/codex_pend.py" --session-file "$session_file" "$@"
}

ping_worker() {
  local name="$1"
  shift || true

  local session_file=""
  if is_ts_name "$name"; then
    session_file="$state_dir/$name.json"
  else
    session_file="$(latest_session_file "$name" 2>/dev/null || true)"
  fi

  if [[ -z "$session_file" || ! -f "$session_file" ]]; then
    echo "‚ùå no session for: $name (run: twf $name)" >&2
    exit 1
  fi

  python3 "$script_dir/codex_ping.py" --session-file "$session_file" "$@"
}

list_workers() {
  local filter="all" # all|running|stopped
  local orphans="false"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --running) filter="running"; shift ;;
      --stopped) filter="stopped"; shift ;;
      --orphans) orphans="true"; shift ;;
      *) echo "Unknown arg: $1" >&2; usage; exit 1 ;;
    esac
  done

  python3 - "$state_dir" "$filter" "$orphans" <<'PY'
import json
import os
import subprocess
import sys
from pathlib import Path

state_dir = Path(sys.argv[1])
filter_mode = sys.argv[2]
orphans_only = sys.argv[3] == "true"

def tmux_running(session: str) -> bool:
    if not session:
        return False
    try:
        subprocess.run(["tmux", "has-session", "-t", session], check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        return True
    except subprocess.CalledProcessError:
        return False

items = []
for p in state_dir.glob("*.json"):
    name = p.stem
    try:
        data = json.loads(p.read_text(encoding="utf-8"))
    except Exception:
        data = {}
    if not isinstance(data, dict):
        data = {}

    tmux_session = data.get("tmux_session") if isinstance(data.get("tmux_session"), str) else name
    running = tmux_running(tmux_session)

    parent = data.get("parent") if isinstance(data.get("parent"), str) else ""
    is_orphan = bool(parent) and not (state_dir / f"{parent}.json").exists()
    if orphans_only and not is_orphan:
        continue

    if filter_mode == "running" and not running:
        continue
    if filter_mode == "stopped" and running:
        continue

    current_id = data.get("codex_current_id") if isinstance(data.get("codex_current_id"), str) else ""
    if not current_id:
        current_id = data.get("codex_session_id") if isinstance(data.get("codex_session_id"), str) else ""
    resume_from = data.get("codex_resume_from_id") if isinstance(data.get("codex_resume_from_id"), str) else ""

    items.append(
        {
            "name": name,
            "mtime": p.stat().st_mtime if p.exists() else 0.0,
            "running": running,
            "parent": parent or None,
            "is_orphan": is_orphan,
            "current": current_id,
            "resume_from": resume_from,
        }
    )

items.sort(key=lambda x: x["mtime"], reverse=True)

for it in items:
    status = "running" if it["running"] else "stopped"
    cur = it["current"][:8] if it["current"] else ""
    res = it["resume_from"][:8] if it["resume_from"] else ""
    extra = []
    if it["parent"]:
        extra.append(f"parent={it['parent']}")
    if it["is_orphan"]:
        extra.append("orphan")
    if res:
        extra.append(f"resume_from={res}")
    if cur:
        extra.append(f"current={cur}")
    suffix = ("  " + "  ".join(extra)) if extra else ""
    print(f"{it['name']}  [{status}]{suffix}")
PY
}

tree_workers() {
  local root="${1:-}"
  shift || true
  [[ $# -eq 0 ]] || { echo "Unknown arg: $1" >&2; usage; exit 1; }

  if [[ -n "$root" ]] && ! is_ts_name "$root"; then
    local sf
    sf="$(latest_session_file "$root" 2>/dev/null || true)"
    if [[ -n "$sf" ]]; then
      root="$(basename "$sf" .json)"
    fi
  fi

  python3 - "$state_dir" "$root" <<'PY'
import json
import subprocess
import sys
from pathlib import Path

state_dir = Path(sys.argv[1])
requested_root = sys.argv[2].strip()

def tmux_running(session: str) -> bool:
    if not session:
        return False
    try:
        subprocess.run(["tmux", "has-session", "-t", session], check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        return True
    except subprocess.CalledProcessError:
        return False

states: dict[str, dict] = {}
mtimes: dict[str, float] = {}
for p in state_dir.glob("*.json"):
    name = p.stem
    try:
        data = json.loads(p.read_text(encoding="utf-8"))
    except Exception:
        data = {}
    if not isinstance(data, dict):
        data = {}
    states[name] = data
    try:
        mtimes[name] = p.stat().st_mtime
    except OSError:
        mtimes[name] = 0.0

def get_str(data: dict, key: str) -> str:
    v = data.get(key)
    return v.strip() if isinstance(v, str) else ""

explicit_children: dict[str, list[str]] = {}
by_parent: dict[str, list[str]] = {}

for name, data in states.items():
    children = data.get("children")
    if isinstance(children, list):
        explicit_children[name] = [c.strip() for c in children if isinstance(c, str) and c.strip()]
    parent = get_str(data, "parent")
    if parent:
        by_parent.setdefault(parent, []).append(name)

def merged_children(name: str) -> list[str]:
    out: list[str] = []
    seen: set[str] = set()
    for c in explicit_children.get(name, []):
        if c in states and c not in seen:
            out.append(c)
            seen.add(c)
    extras = [c for c in by_parent.get(name, []) if c in states and c not in seen]
    extras.sort(key=lambda x: (mtimes.get(x, 0.0), x), reverse=True)
    out.extend(extras)
    return out

def node_line(name: str) -> str:
    data = states.get(name, {})
    tmux_session = get_str(data, "tmux_session") or name
    running = tmux_running(tmux_session)
    status = "running" if running else "stopped"
    current_id = get_str(data, "codex_current_id") or get_str(data, "codex_session_id")
    resume_from = get_str(data, "codex_resume_from_id")
    cur = current_id[:8] if current_id else ""
    res = resume_from[:8] if resume_from else ""
    parts = [f"[{status}]"]
    if res:
        parts.append(f"resume_from={res}")
    if cur:
        parts.append(f"current={cur}")
    return f"{name}  " + "  ".join(parts)

def render(root: str, prefix: str = "") -> None:
    seen: set[str] = set([root])
    print(prefix + node_line(root))
    render_children(root, prefix, seen)

def render_children(node: str, prefix: str, seen: set[str]) -> None:
    kids = merged_children(node)
    for i, c in enumerate(kids):
        is_last = i == len(kids) - 1
        branch = "‚îî‚îÄ " if is_last else "‚îú‚îÄ "
        next_prefix = prefix + ("   " if is_last else "‚îÇ  ")
        if c in seen:
            print(prefix + branch + node_line(c) + "  (cycle)")
            continue
        seen.add(c)
        print(prefix + branch + node_line(c))
        render_children(c, next_prefix, seen)

if requested_root:
    if requested_root not in states:
        print(f"‚ùå root not found: {requested_root}", file=sys.stderr)
        raise SystemExit(1)
    render(requested_root)
    raise SystemExit(0)

# roots: nodes with no parent in-state
roots = []
for name, data in states.items():
    parent = get_str(data, "parent")
    if not parent or parent not in states:
        roots.append(name)
roots.sort(key=lambda x: (mtimes.get(x, 0.0), x), reverse=True)

if not roots:
    print("(no workers)")
    raise SystemExit(0)

for r in roots:
    render(r)
PY
}

stop_worker() {
  local name="$1"
  shift || true

  local session_file
  session_file="$(resolve_session_file_or_fail "$name")"

  lock_state
  trap 'unlock_state' RETURN

  local meta=()
  readarray -t meta < <(
    python3 - "$session_file" "$script_dir" <<'PY'
import json
import os
import sys
import shlex
from pathlib import Path

p = Path(sys.argv[1])
script_dir = Path(sys.argv[2])
try:
    data = json.loads(p.read_text(encoding="utf-8"))
except Exception:
    data = {}

def get_str(key: str) -> str:
    v = data.get(key)
    return v if isinstance(v, str) else ""

tmux_session = get_str("tmux_session") or p.stem
codex_home = get_str("codex_home")
sessions_root = get_str("codex_session_root") or (str(Path(codex_home).expanduser() / "sessions") if codex_home else "")

print(tmux_session)
print(codex_home)
print(sessions_root)
PY
  )

  local tmux_session="${meta[0]:-}"
  local codex_home="${meta[1]:-}"
  local sessions_root="${meta[2]:-}"
  if [[ -z "$tmux_session" ]]; then
    tmux_session="$name"
  fi

  local log_path=""
  local sid=""
  if [[ -n "$sessions_root" ]]; then
    local info=()
    readarray -t info < <(scan_latest_log_info "$sessions_root")
    log_path="${info[0]:-}"
    sid="${info[1]:-}"
  fi

  if tmux has-session -t "$tmux_session" >/dev/null 2>&1; then
    tmux kill-session -t "$tmux_session" >/dev/null 2>&1 || true
    echo "üõë stopped tmux session: $tmux_session" >&2
  else
    echo "‚ÑπÔ∏è  tmux session not running: $tmux_session" >&2
  fi

  local now
  now="$(now_human)"
  python3 - "$session_file" "$now" "$log_path" "$sid" <<'PY'
import json
import sys
from pathlib import Path

p = Path(sys.argv[1])
now = sys.argv[2]
log_path = sys.argv[3] or None
sid = sys.argv[4] or None

try:
    data = json.loads(p.read_text(encoding="utf-8"))
except Exception:
    data = {}

data["active"] = False
data["stopped_at"] = now

if log_path:
    data["codex_session_path"] = log_path
if sid:
    data["codex_current_id"] = sid
    data["codex_resume_from_id"] = sid
    # Back-compat fields
    data["codex_session_id"] = sid

tmp = p.with_suffix(p.suffix + ".tmp")
tmp.parent.mkdir(parents=True, exist_ok=True)
tmp.write_text(json.dumps(data, ensure_ascii=False, indent=2) + "\n", encoding="utf-8")
tmp.replace(p)
PY
}

resume_worker_inner() {
  local name="$1"
  local tree="${2:-true}"

  local session_file
  session_file="$(resolve_session_file_or_fail "$name")"
  local full_name
  full_name="$(basename "$session_file" .json)"

  if [[ -n "${TWF_RESUME_VISITED[$full_name]:-}" ]]; then
    return 0
  fi
  TWF_RESUME_VISITED["$full_name"]=1

  local meta=()
  readarray -t meta < <(
    python3 - "$session_file" "$script_dir" "$config_file" <<'PY'
import json
import os
import sys
import shlex
from pathlib import Path

p = Path(sys.argv[1])
script_dir = Path(sys.argv[2])
cfg_path = Path(sys.argv[3]).expanduser()
try:
    data = json.loads(p.read_text(encoding="utf-8"))
except Exception:
    data = {}

def get_str(key: str) -> str:
    v = data.get(key)
    return v if isinstance(v, str) else ""

tmux_session = get_str("tmux_session") or p.stem
work_dir = get_str("work_dir") or os.getcwd()
codex_home = get_str("codex_home")
codex_home_src = get_str("codex_home_src")
auth_src = get_str("auth_src")
codex_cmd = get_str("codex_start_cmd") or os.environ.get("TWF_CODEX_CMD", "")
resume_id = get_str("codex_resume_from_id") or get_str("codex_current_id") or get_str("codex_session_id")

raw_cfg = ""
try:
    if cfg_path.exists():
        raw_cfg = cfg_path.read_text(encoding="utf-8")
except Exception:
    raw_cfg = ""

def parse_yaml(text: str) -> dict:
    out: dict[str, str] = {}
    for line in text.splitlines():
        stripped = line.strip()
        if not stripped or stripped.startswith("#"):
            continue
        if ":" not in stripped:
            continue
        key, value = stripped.split(":", 1)
        key = key.strip()
        if not key:
            continue
        value = value.strip()
        if not value:
            out[key] = ""
            continue
        if value[0] in {"'", '"'}:
            q = value[0]
            if value.endswith(q) and len(value) >= 2:
                out[key] = value[1:-1]
            else:
                out[key] = value[1:]
            continue
        if "#" in value:
            for i, ch in enumerate(value):
                if ch == "#" and (i == 0 or value[i - 1].isspace()):
                    value = value[:i].strip()
                    break
        out[key] = value.strip()
    return out

cfg = {}
try:
    if raw_cfg.lstrip().startswith("{"):
        cfg = json.loads(raw_cfg)
        if not isinstance(cfg, dict):
            cfg = {}
    else:
        cfg = parse_yaml(raw_cfg)
except Exception:
    cfg = parse_yaml(raw_cfg)

model = cfg.get("model") if isinstance(cfg.get("model"), str) else "gpt-5.2"
effort = cfg.get("model_reasoning_effort") if isinstance(cfg.get("model_reasoning_effort"), str) else "xhigh"
model = model.strip()
effort = effort.strip()

def has_effort_override(args: list[str]) -> bool:
    for i, a in enumerate(args):
        if a in ("--config", "-c") and i + 1 < len(args):
            v = args[i + 1]
            if isinstance(v, str) and v.startswith("model_reasoning_effort="):
                return True
    return False

def ensure_cmd(cmd: str) -> str:
    try:
        args = shlex.split(cmd)
    except Exception:
        return cmd

    if "--dangerously-bypass-approvals-and-sandbox" not in args and "--full-auto" not in args:
        if "--sandbox" not in args and "-s" not in args:
            args.extend(["--sandbox", "danger-full-access"])

    if model and "-m" not in args and "--model" not in args:
        args.extend(["-m", model])

    if effort and not has_effort_override(args):
        args.extend(["--config", f'model_reasoning_effort="{effort}"'])

    return " ".join(shlex.quote(a) for a in args)

def build_default_cmd() -> str:
    args: list[str] = ["codex", "-c", "disable_paste_burst=true", "--sandbox", "danger-full-access"]
    if model:
        args.extend(["-m", model])
    if effort:
        args.extend(["--config", f'model_reasoning_effort="{effort}"'])
    return " ".join(shlex.quote(a) for a in args)

codex_cmd = ensure_cmd(codex_cmd) if codex_cmd else build_default_cmd()

children = data.get("children")
if not isinstance(children, list):
    children = []
children = [c for c in children if isinstance(c, str) and c.strip()]

print(tmux_session)
print(work_dir)
print(codex_home)
print(codex_home_src)
print(auth_src)
print(codex_cmd)
print(resume_id)
print("\n".join(children))
PY
  )

  local tmux_session="${meta[0]:-}"
  local work_dir="${meta[1]:-$PWD}"
  local codex_home="${meta[2]:-}"
  local codex_home_src="${meta[3]:-}"
  local auth_src="${meta[4]:-}"
  local codex_cmd="${meta[5]:-codex -c disable_paste_burst=true}"
  local resume_id="${meta[6]:-}"
  local codex_home_src_final="$codex_home_src"
  local auth_src_final="$auth_src"
  local profile_final="${TWF_CODEX_PROFILE:-}"

  if [[ -z "$codex_home" ]]; then
    echo "‚ùå codex_home missing in state: $session_file" >&2
    exit 1
  fi

  if tmux has-session -t "$tmux_session" >/dev/null 2>&1; then
    echo "‚ÑπÔ∏è  already running: $tmux_session" >&2
  else
    if [[ ! -d "$codex_home" ]]; then
      if [[ -n "$resume_id" ]]; then
        echo "‚ùå codex_home missing, cannot resume with id: $codex_home" >&2
        exit 1
      fi
      mkdir -p "$codex_home"
    fi

    if [[ -z "$codex_home_src_final" ]]; then
      codex_home_src_final="${TWF_CODEX_HOME_SRC:-}"
    fi
    if [[ -z "$codex_home_src_final" ]] && lower_bool "$twf_use_lb"; then
      codex_home_src_final="$(pick_codex_home_src "$tmux_session" "$(base_from_full "$tmux_session")")"
    fi
    if [[ -z "$codex_home_src_final" ]]; then
      codex_home_src_final="$HOME/.codex"
    fi

    # When load balancer is disabled, prefer config-driven profile/auth over state,
    # so operators can switch providers/credentials via twf_config.yaml and resume safely.
    if ! lower_bool "$twf_use_lb"; then
      auth_src_final="${TWF_AUTH_SRC:-}"
      if [[ -z "$profile_final" ]]; then
        profile_final="$twf_profile_cfg"
      fi
      if [[ -z "$auth_src_final" ]] && [[ -n "$twf_auth_src_cfg" ]]; then
        auth_src_final="$(resolve_auth_src_cfg "$twf_auth_src_cfg")"
      fi
    else
      if [[ -z "$auth_src_final" ]]; then
        auth_src_final="${TWF_AUTH_SRC:-}"
      fi
      if [[ -z "$auth_src_final" ]]; then
        auth_src_final="$(pick_auth_src "$tmux_session" "$(base_from_full "$tmux_session")")"
      fi
    fi

    if ! lower_bool "$twf_use_lb" && [[ -n "$profile_final" ]]; then
      codex_cmd="$(python3 - "$profile_final" "$codex_cmd" <<'PY'
import shlex, sys
profile = sys.argv[1].strip()
cmd = sys.argv[2]
try:
    parts = shlex.split(cmd)
except Exception:
    print(cmd)
    raise SystemExit(0)
if not parts or parts[0] != "codex" or not profile:
    print(cmd)
    raise SystemExit(0)
for flag in ("-p", "--profile"):
    if flag in parts:
        i = parts.index(flag)
        if i + 1 < len(parts):
            parts[i + 1] = profile
        print(" ".join(shlex.quote(p) for p in parts))
        raise SystemExit(0)
parts = [parts[0], "-p", profile] + parts[1:]
print(" ".join(shlex.quote(p) for p in parts))
PY
)"
    fi

    echo "üîß Syncing CODEX_HOME -> $codex_home (excluding sessions/log/history.jsonl)" >&2
    python3 "$script_dir/sync_codex_home.py" --src "$codex_home_src_final" --dst "$codex_home" >/dev/null

    if [[ -n "$auth_src_final" ]]; then
      if [[ ! -f "$auth_src_final" ]]; then
        echo "‚ùå auth source missing (expected file): $auth_src_final" >&2
        exit 1
      fi
      cp -f "$auth_src_final" "$codex_home/auth.json"
      chmod 600 "$codex_home/auth.json" >/dev/null 2>&1 || true
      # Ensure we don't carry a pinned auth selector from the template.
      rm -f "$codex_home/.auth_current_name" >/dev/null 2>&1 || true
    fi

    local quoted_codex_home
    quoted_codex_home="$(python3 -c 'import shlex,sys; print(shlex.quote(sys.argv[1]))' "$codex_home")"
    local cmd="$codex_cmd"
    if [[ -n "$resume_id" ]]; then
      local quoted_id
      quoted_id="$(python3 -c 'import shlex,sys; print(shlex.quote(sys.argv[1]))' "$resume_id")"
      cmd="$cmd resume $quoted_id"
    fi
    tmux new-session -d -s "$tmux_session" -c "$work_dir" "env CODEX_HOME=$quoted_codex_home $cmd"
    tmux set-environment -t "$tmux_session" CODEX_HOME "$codex_home" >/dev/null 2>&1 || true
    echo "‚ñ∂Ô∏è  resumed tmux session: $tmux_session" >&2
  fi

  local tmux_target="${tmux_session}:0.0"
  local pane_id
  pane_id="$(tmux display-message -p -t "$tmux_target" '#{pane_id}' 2>/dev/null || true)"

  local sessions_root="$codex_home/sessions"
  local log_path=""
  local sid=""
  local deadline=$((SECONDS + 10))
  while [[ $SECONDS -lt $deadline ]]; do
    local info=()
    readarray -t info < <(scan_latest_log_info "$sessions_root")
    log_path="${info[0]:-}"
    sid="${info[1]:-}"
    if [[ -n "$log_path" ]]; then
      break
    fi
    sleep 0.2
  done

  local now
  now="$(now_human)"
  python3 - "$session_file" "$now" "$tmux_session" "$tmux_target" "$pane_id" "$work_dir" "$codex_home" "$codex_home_src_final" "$auth_src_final" "$sessions_root" "$codex_cmd" "$log_path" "$sid" "$resume_id" <<'PY'
import json
import sys
from pathlib import Path

p = Path(sys.argv[1])
now = sys.argv[2]
tmux_session = sys.argv[3]
tmux_target = sys.argv[4]
pane_id = sys.argv[5] or None
work_dir = sys.argv[6]
codex_home = sys.argv[7]
codex_home_src = sys.argv[8] or None
auth_src = sys.argv[9] or None
sessions_root = sys.argv[10]
codex_cmd = sys.argv[11]
log_path = sys.argv[12] or None
sid = sys.argv[13] or None
resume_id = sys.argv[14] or None

try:
    data = json.loads(p.read_text(encoding="utf-8"))
except Exception:
    data = {}

data.update(
    {
        "terminal": "tmux",
        "tmux_session": tmux_session,
        "tmux_target": tmux_target,
        "pane_id": pane_id,
        "work_dir": work_dir,
        "worker_id": data.get("worker_id") or tmux_session,
        "codex_home": codex_home,
        "codex_home_src": codex_home_src,
        "auth_src": auth_src,
        "codex_session_root": sessions_root,
        "active": True,
        "resumed_at": now,
        "codex_start_cmd": codex_cmd,
    }
)

if log_path:
    data["codex_session_path"] = log_path
if sid:
    data["codex_current_id"] = sid
    data["codex_session_id"] = sid  # back-compat

if resume_id and codex_cmd:
    data["codex_resume_cmd"] = f"{codex_cmd} resume {resume_id}"

tmp = p.with_suffix(p.suffix + ".tmp")
tmp.parent.mkdir(parents=True, exist_ok=True)
tmp.write_text(json.dumps(data, ensure_ascii=False, indent=2) + "\n", encoding="utf-8")
tmp.replace(p)
PY

  if [[ "$tree" != "true" ]]; then
    return 0
  fi

  local child
  for child in "${meta[@]:7}"; do
    [[ -n "$child" ]] || continue

    local resolved="$child"
    if ! is_ts_name "$child"; then
      local sf
      sf="$(latest_session_file "$child" 2>/dev/null || true)"
      if [[ -z "$sf" ]]; then
        echo "‚ö†Ô∏è  child state missing, skipping: $child" >&2
        continue
      fi
      resolved="$(basename "$sf" .json)"
    else
      if [[ ! -f "$state_dir/$child.json" ]]; then
        echo "‚ö†Ô∏è  child state missing, skipping: $child" >&2
        continue
      fi
    fi

    resume_worker_inner "$resolved" "true"
  done
}

resume_worker() {
  local name="$1"
  shift || true

  declare -gA TWF_RESUME_VISITED=()

  local tree="true"
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --tree) tree="true"; shift ;;
      --no-tree) tree="false"; shift ;;
      *) echo "Unknown arg: $1" >&2; usage; exit 1 ;;
    esac
  done

  lock_state
  trap 'unlock_state' RETURN

  resume_worker_inner "$name" "$tree"
}

spawn_worker() {
  local parent="$1"
  local child_base="$2"
  shift 2 || true

  if ! is_ts_name "$parent"; then
    echo "‚ùå spawn requires a full parent name like: <base>-YYYYmmdd-HHMMSS-<pid>" >&2
    echo "   provided: $parent" >&2
    exit 1
  fi

  local parent_file="$state_dir/$parent.json"
  if [[ ! -f "$parent_file" ]]; then
    echo "‚ùå parent state not found: $parent_file" >&2
    exit 1
  fi

  local child_file
  child_file="$(start_worker "$child_base" "$@")"
  local child_full
  child_full="$(basename "$child_file" .json)"

  lock_state
  trap 'unlock_state' RETURN

  python3 - "$child_file" "$parent" <<'PY'
import json
import sys
from pathlib import Path

p = Path(sys.argv[1])
parent = sys.argv[2]
try:
    data = json.loads(p.read_text(encoding="utf-8"))
except Exception:
    data = {}
data["parent"] = parent
tmp = p.with_suffix(p.suffix + ".tmp")
tmp.write_text(json.dumps(data, ensure_ascii=False, indent=2) + "\n", encoding="utf-8")
tmp.replace(p)
PY

  python3 - "$parent_file" "$child_full" <<'PY'
import json
import sys
from pathlib import Path

p = Path(sys.argv[1])
child = sys.argv[2]
try:
    data = json.loads(p.read_text(encoding="utf-8"))
except Exception:
    data = {}
children = data.get("children")
if not isinstance(children, list):
    children = []
children = [c for c in children if isinstance(c, str) and c.strip()]
if child not in children:
    children.append(child)
data["children"] = children
tmp = p.with_suffix(p.suffix + ".tmp")
tmp.write_text(json.dumps(data, ensure_ascii=False, indent=2) + "\n", encoding="utf-8")
tmp.replace(p)
PY

  echo "$child_file"
}

remove_worker() {
  local full="$1"
  shift || true

  local recursive="true"
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --recursive) recursive="true"; shift ;;
      --no-recursive) recursive="false"; shift ;;
      *) echo "Unknown arg: $1" >&2; usage; exit 1 ;;
    esac
  done

  if ! is_ts_name "$full"; then
    echo "‚ùå remove requires a full worker name like: <base>-YYYYmmdd-HHMMSS-<pid>" >&2
    echo "   provided: $full" >&2
    echo "   hint: list candidates via: ls -t \"$state_dir/${full}-\"*.json" >&2
    exit 1
  fi

  lock_state
  trap 'unlock_state' RETURN

  local rootsession="$state_dir/$full.json"
  if [[ ! -f "$rootsession" ]]; then
    echo "‚ùå session file not found: $rootsession" >&2
    exit 1
  fi

  local nodes=()
  if [[ "$recursive" == "true" ]]; then
    readarray -t nodes < <(
      python3 - "$state_dir" "$full" <<'PY'
import json
import sys
from pathlib import Path

state_dir = Path(sys.argv[1])
root = sys.argv[2]

states: dict[str, dict] = {}
for p in state_dir.glob("*.json"):
    name = p.stem
    try:
        data = json.loads(p.read_text(encoding="utf-8"))
    except Exception:
        data = {}
    if isinstance(data, dict):
        states[name] = data
    else:
        states[name] = {}

adj: dict[str, list[str]] = {name: [] for name in states}
seen: dict[str, set[str]] = {name: set() for name in states}

def add_edge(parent: str, child: str) -> None:
    if not parent or not child:
        return
    if parent not in adj:
        adj[parent] = []
        seen[parent] = set()
    if child in seen[parent]:
        return
    seen[parent].add(child)
    adj[parent].append(child)

# parent.children[] edges (preserve order)
for name, data in states.items():
    children = data.get("children")
    if isinstance(children, list):
        for c in children:
            if isinstance(c, str) and c.strip():
                add_edge(name, c.strip())

# child.parent edges (append; order unspecified)
for child, data in states.items():
    parent = data.get("parent")
    if isinstance(parent, str) and parent.strip():
        add_edge(parent.strip(), child)

visited: set[str] = set()
order: list[str] = []

def dfs(n: str) -> None:
    if n in visited:
        return
    visited.add(n)
    for c in adj.get(n, []):
        if c in states:
            dfs(c)
    order.append(n)

dfs(root)
print("\n".join(order))
PY
    )
  else
    nodes=("$full")
  fi

  if [[ ${#nodes[@]} -eq 0 ]]; then
    echo "‚ùå nothing to remove for: $full" >&2
    exit 1
  fi

  local node
  for node in "${nodes[@]}"; do
    local session_file="$state_dir/$node.json"
    if [[ ! -f "$session_file" ]]; then
      echo "‚ö†Ô∏è  state missing, skipping: $session_file" >&2
      tmux kill-session -t "$node" >/dev/null 2>&1 || true
      continue
    fi

    local meta=()
    readarray -t meta < <(
      python3 - "$session_file" <<'PY'
import json
import sys
from pathlib import Path

p = Path(sys.argv[1])
try:
    data = json.loads(p.read_text(encoding="utf-8"))
except Exception:
    data = {}

def get_str(key: str) -> str:
    v = data.get(key)
    return v if isinstance(v, str) else ""

tmux_session = get_str("tmux_session") or p.stem
codex_home = get_str("codex_home")
parent = get_str("parent")
print(tmux_session)
print(codex_home)
print(parent)
PY
    )

    local tmux_session="${meta[0]:-$node}"
    local codex_home="${meta[1]:-}"
    local parent="${meta[2]:-}"

    if tmux has-session -t "$tmux_session" >/dev/null 2>&1; then
      tmux kill-session -t "$tmux_session" >/dev/null 2>&1 || true
      echo "üõë stopped tmux session: $tmux_session" >&2
    else
      echo "‚ÑπÔ∏è  tmux session not running: $tmux_session" >&2
    fi

    if [[ -n "$codex_home" ]]; then
      local base_default="$HOME/.codex-workers"
      local base_env="${TWF_WORKERS_DIR:-$base_default}"
      local ok="false"
      ok="$(
        python3 - "$codex_home" "$base_env" "$base_default" <<'PY'
import sys
from pathlib import Path

home = Path(sys.argv[1]).expanduser().resolve()
bases = [Path(sys.argv[2]).expanduser().resolve(), Path(sys.argv[3]).expanduser().resolve()]

def is_strict_child(path: Path, base: Path) -> bool:
    try:
        path.relative_to(base)
        return path != base
    except Exception:
        return False

for base in bases:
    if is_strict_child(home, base):
        print("true")
        raise SystemExit(0)

print("false")
PY
      )"
      if [[ "$ok" == "true" ]]; then
        rm -rf -- "$codex_home"
        echo "üßπ removed worker CODEX_HOME: $codex_home" >&2
      else
        echo "‚ö†Ô∏è  refused to delete codex_home outside workers dir: $codex_home" >&2
        echo "   (set TWF_WORKERS_DIR appropriately or delete manually)" >&2
      fi
    fi

    rm -f -- "$session_file"
    echo "üóëÔ∏è  removed session file: $session_file" >&2

    if [[ -n "$parent" && -f "$state_dir/$parent.json" ]]; then
      python3 - "$state_dir/$parent.json" "$node" <<'PY'
import json
import sys
from pathlib import Path

p = Path(sys.argv[1])
child = sys.argv[2]
try:
    data = json.loads(p.read_text(encoding="utf-8"))
except Exception:
    data = {}
children = data.get("children")
if isinstance(children, list):
    children = [c for c in children if isinstance(c, str) and c.strip() and c != child]
    data["children"] = children
tmp = p.with_suffix(p.suffix + ".tmp")
tmp.write_text(json.dumps(data, ensure_ascii=False, indent=2) + "\n", encoding="utf-8")
tmp.replace(p)
PY
    fi
  done
}

cmd="${1:-}"
case "$cmd" in
  ""|-h|--help|help)
    usage
    exit 0
    ;;
  up)
    [[ $# -ge 2 ]] || { echo "‚ùå missing name" >&2; usage; exit 1; }
    shift
    start_worker "$@"
    ;;
  ask)
    [[ $# -ge 2 ]] || { echo "‚ùå missing name" >&2; usage; exit 1; }
    shift
    ask_worker "$@"
    ;;
  pend)
    [[ $# -ge 2 ]] || { echo "‚ùå missing name" >&2; usage; exit 1; }
    shift
    pend_worker "$@"
    ;;
  ping)
    [[ $# -ge 2 ]] || { echo "‚ùå missing name" >&2; usage; exit 1; }
    shift
    ping_worker "$@"
    ;;
  self|whoami)
    self_worker
    ;;
  spawn-self)
    shift
    spawn_self_worker "$@"
    ;;
  stop)
    [[ $# -ge 2 ]] || { echo "‚ùå missing name" >&2; usage; exit 1; }
    shift
    stop_worker "$@"
    ;;
  resume)
    [[ $# -ge 2 ]] || { echo "‚ùå missing name" >&2; usage; exit 1; }
    shift
    resume_worker "$@"
    ;;
  spawn)
    [[ $# -ge 3 ]] || { echo "‚ùå usage: twf spawn <parent-full> <child-base> [up-args...]" >&2; usage; exit 1; }
    shift
    spawn_worker "$@"
    ;;
  tree)
    shift
    tree_workers "$@"
    ;;
  list|ls)
    shift
    list_workers "$@"
    ;;
  remove|rm)
    [[ $# -ge 2 ]] || { echo "‚ùå missing full name" >&2; usage; exit 1; }
    shift
    remove_worker "$@"
    ;;
  *)
    name="$cmd"
    shift || true
    if [[ $# -gt 0 ]]; then
      ask_worker "$name" "$@"
    else
      start_worker "$name"
    fi
    ;;
esac
